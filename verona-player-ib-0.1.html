<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Verona Player for ItemBuilder</title>
  <link rel="icon" href="data:,">
  <script type="application/ld+json">
    {
      "$schema": "https://raw.githubusercontent.com/verona-interfaces/metadata/master/verona-module-metadata.json",
      "type": "player",
      "id": "verona-player-ib",
      "name": [
        {
          "value": "Verona Player for DIPF Item Builder Items using IB Runtime: «««« ibVersion »»»»)",
          "lang": "en"
        }
      ],
      "version": "0.0.1",
      "specVersion": "6.0",
      "description": [
        {
          "value": "TODO",
          "lang": "en"
        }
      ],
      "maintainer": {
        "name": [
          {
            "value": "IQB - Institute for Educational Quality Improvement",
            "lang": "en"
          }
        ],
        "email": "iqb-tbadev@hu-berlin.de",
        "url": "https://www.iqb.hu-berlin.de"
      },
      "code": {
        "repositoryUrl": "https://github.com/iqb-berlin/verona-modules-ib",
        "repositoryType": "git",
        "licenseType": "MIT",
        "licenseUrl": "https://raw.githubusercontent.com/iqb-berlin/verona-modules-ib/main/LICENSE"
      },
      "metadataVersion": "2.0"
    }
  </script>

  <style>
    html, body {
      height: 100vh;
      overflow: hidden;
      font-family: sans-serif;
      margin: 0;
      background: #5e93c5
    }
  </style>

</head>
<body>


  <iframe id='ib-runtime-host' style='margin: 0; padding: 0; border: 1px solid indianred; position: fixed; height: calc(100vh - 2px); width: calc(100vw - 2px); background: white'></iframe>

  <script>
    const unitStateDataType = "iqb-standard@1.3";

    const taskPlayerElem = document.getElementById('ib-runtime-host');

    const playerMetaData = JSON.parse(document.querySelector('script[type="application/ld+json"]').innerText)

    let playerConfig = {
      logPolicy: 'eager', // "disabled" | "lean" | "rich" | "debug"
      unitNumber: 0,
      unitTitle: 'Unit',
      unitId: 'unit',
      enabledNavigationTargets: [], // can contain  "next" "previous" "first" "last" "end"
      pagingMode: "buttons", // "separate" | "concat-scroll" | "concat-scroll-snap" | "buttons"
      printMode: "off",
      startPage: null,
      directDownloadUrl: null,
    }

    let sessionId = "";

    const Format = new class {
      parse = format => {
        const parts = format.match(/(^.+)[-@](\d+)(.(\d+))?(.(\d+))?(-(.+))?$/);
        return parts ? {
          format: parts[1] || format,
          major: parseInt(parts[2] || 0),
          minor: parseInt(parts[4] || 0),
          patch: parseInt(parts[6] || 0),
          label: parts[8] || ''
        } : format;
      }
      isSupportedBy = (format1, format2) => {
        const v1 = Format.parse(format1);
        const v2 = Format.parse(format2);
        if (v1.format !== v2.format) return false;
        if (v1.major !== v2.major) return false;
        return (v1.minor <= v2.minor);
      };
    }

    const TaskPlayer = new class {
      receive = (type, message) => {
        console.log('got', type);
        switch (type) {
          case 'getTasksStateReturn':
            return Message.send.vopStateChangedNotification({
              unitState: {
                dataParts: {
                  variables: JSON.stringify(IBVariables.toIQBStandard(message.state.variables)),
                  fullState: JSON.stringify({ // VERONA 6 only allows one UnitStateDatatype, so have to wrap the full state here
                    id: 'fullState',
                    value: JSON.stringify(message.state),
                    state: 'VALUE_CHANGED'
                  })
                },
                presentationProgress: 'some', // TODO
                responseProgress: 'some', // TODO
              },
              unitStateDataType
            });
          case 'getScoringResultReturn': {
            return Message.send.vopStateChangedNotification({
              unitState: {
                dataParts: {
                  scores: JSON.stringify(message.result),
                },
                presentationProgress: 'some', // TODO
                responseProgress: 'some', // TODO
              },
              unitStateDataType
            });
          }
          case 'taskSwitchRequest': {
            switch (message.request) {
              case 'nextTask': return Message.send.vopUnitNavigationRequestedNotification('next');
              case 'previousTask': return Message.send.vopUnitNavigationRequestedNotification('previous');
            }
            throw new Error(`Target not supported by verona-player-ib: '${message.request}'`);
          }
        }
      }
      send = msg => {
        taskPlayerElem.contentWindow.postMessage(JSON.stringify(msg), { targetOrigin: '*'});
      };
    }

    const IBVariables = new class {
      toIQBStandard = variablesList => Object.entries(variablesList)
        .map(([hostItem, variablesList]) => {
          console.log(hostItem, variablesList);
          return Object.values(variablesList)
            .map(variable => ({
              id: this._toIQBStandardVarId(variable.name),
              state: "VALUE_CHANGED",
              value: this._toIQBStandardValueType(variable.value),
              subForm: hostItem
            }));
        });

      _toIQBStandardVarId = variableName => variableName
        .replaceAll(/[^0-9a-zA-Z_]/g, c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);

      _toIQBStandardValueType = value => {
        if (typeof value === 'undefined') return null;
        if (['number', 'string', 'boolean'].includes(typeof value)) return value;
        if (Array.isArray(value)) {
          const types = value.reduce((agg, value) => {
            if (!agg.includes(typeof value)) {
              agg.push(typeof value);
            }
            return agg;
          }, []);
          return value.map(types.length > 1 ? JSON.stringify : this._toIQBStandardValueType);
        }
        return JSON.stringify(value);
      }
    }

    const Message = new class {
      send = new class {

        vopStateChangedNotification = ({unitState, playerState, log}) => {
          this._send({
            type: 'vopStateChangedNotification',
            sessionId: sessionId,
            timeStamp: Date.now(),
            unitState,
            playerState,
            log
          });
        };

        vopReadyNotification = () => {
          this._send({
            type: 'vopReadyNotification',
            metadata: playerMetaData
          });
        };

        vopUnitNavigationRequestedNotification = target => {
          this._send({
            type: 'vopUnitNavigationRequestedNotification',
            sessionId,
            target,
          });
        };

        vopWindowFocusChangedNotification = hasFocus => {
          this._send({
            type: 'vopWindowFocusChangedNotification',
            sessionId,
            hasFocus
          });
        }

        vopRuntimeErrorNotification = (code, message) => {
          this._send({
            type: 'vopRuntimeErrorNotification',
            sessionId,
            code,
            message
          })
        }

        _send = msg => {
          window.parent.postMessage(msg, '*');
          document.dispatchEvent(new CustomEvent('sent:' + msg.type, {detail: msg}));
        }
      }

      receive = (type, data) => {
        if (data.eventType === "taskPlayerReady") {
          console.log(data);
        } else if (type === "vopStartCommand") {
          Unit.start(data);
          document.dispatchEvent(new CustomEvent(type, { detail: data }));
        } else if (sessionId && (data.sessionId !== sessionId) && type && type.startsWith('vop')) {
          throw new VspRuntimeError('wrong-session-id', `Wrong Session-Id: '${sessionId}' (was: '${sessionId}').`);
        } else if (sessionId) {
          document.dispatchEvent(new CustomEvent(type, { detail: data }));
        } else {
          console.warn(`Message before first vopStartCommand, ignored: ${type}`, data);
        }
      };
    }

    const Unit = new class {
      definition = {
        runtimeVersion : undefined,
        item: undefined,
        task: undefined,
        scope: undefined
      }

      start = async data => {
        if (!data.sessionId) {
          throw new VspRuntimeError("session-id-missing", "Session-Id is missing.");
        }
        sessionId = data.sessionId;
        if (!data.unitDefinition) {
          throw new VspRuntimeError("unit-definition-missing", "Unit-Definition is missing.")
        }
        this._setPlayerConfig(data.playerConfig || {});

        console.log('what now?');


        const ib2veronaFile = JSON.parse(data.unitDefinition);
        // TODO catch error
        this._setUnit(ib2veronaFile);


        await this._loadTaskPlayer();
      }

      _loadTaskPlayer = async () => {
        // -- load runtime version
        taskPlayerElem.addEventListener('load', this._startTaskPlayer);
        taskPlayerElem.addEventListener('error', () => { throw new Error('could not load'); });
        taskPlayerElem.src = playerConfig.directDownloadUrl + 'runtimes/ib-runtime.' + this.definition.runtimeVersion + '.html';
      }

      _startTaskPlayer = async () => {
        // -- login
        TaskPlayer.send({ eventType: 'setUserId', id: 'verona:' + sessionId });

        // unit path
        const unitPath = playerConfig.directDownloadUrl + 'units/' + this.definition.item;

        // -- get item config
        const configFileCallResponse = await fetch(unitPath + '/config.json');
        if (!configFileCallResponse.ok) {
          console.error(configFileCallResponse);
          throw new Error('Network response was not ok');
        }

        const itemConfig = await configFileCallResponse.json();
        // TODO catch error

        // -- set taskSequencer
        TaskPlayer.send({
          eventType: 'setTaskSequencer',
          targetWindowType: 'parent', // !
          targetOrigin: '*', // !,

        });

        // -- push item to taskplayer
        const mathJaxCdnUrl = undefined;
        TaskPlayer.send({
          eventType: 'addItem',
          itemConfig,
          resourcePath: `${unitPath}/resources`,
          externalResourcePath: `${unitPath}/external-resources`,
          libraryPathsMap: { MathJax: mathJaxCdnUrl === undefined ? 'math-jax unknown' : mathJaxCdnUrl }
        });

        TaskPlayer.send({
          eventType: 'startTask',
          item: this.definition.item,
          task: this.definition.task,
          scope: this.definition.scope
        });
      }

      _setUnit = unitDef => {
        Object.keys(this.definition)
          .forEach(field => {
            if (typeof unitDef[field] === 'undefined') {
              console.log(unitDef);
              throw new Error(`Invalid Unit Definition, ${field} missing`);
            }
            this.definition[field] = unitDef[field];
          });
      }

      _setPlayerConfig = newPlayerConfig => {
        playerConfig = Object.assign(playerConfig, newPlayerConfig);
      };
    }

    class VspRuntimeError extends Error {
      name = 'VspRuntimeError';
      constructor(code, message) {
        super(message);
        this.code = code;
      }
    }

    window.addEventListener('message', event => {
      if (typeof event.data === 'object'
        && typeof event.data.type !== 'undefined'
        && event.data.type.startsWith('vop')
      ) {
        Message.receive(event.data.type, event.data)
      } else if (typeof event.data === 'string'
        && event.data.includes('"eventType":')
      ) {
        const data = JSON.parse(event.data);
        TaskPlayer.receive(data.eventType, data);
      } else {
        console.log('unknown message: ', event.data);
      }
    }, false);

    window.addEventListener('error', event => {
      return; // TODO check if window == self
      if (event.error.name === VspRuntimeError.name) {
        Message.send.vopRuntimeErrorNotification(event.error.code, event.error.message);
      } else {
        Message.send.vopRuntimeErrorNotification('runtime-error', event.error.message);
      }
    }, false);

    document.addEventListener("DOMContentLoaded", Message.send.vopReadyNotification);

    document.addEventListener("vopPageNavigationCommand", event => { /* TODO */ });
    document.addEventListener("vopNavigationDeniedNotification", event => { /* TODO */ });
    document.addEventListener("vopPlayerConfigChangedNotification", event => { /* TODO */ });

    setInterval(() => {
      TaskPlayer.send({
        eventType: "getTasksState"
      });
    }, 2500);
    setInterval(() => {
      TaskPlayer.send({
        eventType: "getScoringResult"
      });
    }, 5000);

  </script>
</body>
</html>
